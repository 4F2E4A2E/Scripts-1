/* Strahler_Analysis.bsh
 * BeanShell script that performs Strahler analysis in ImageJ by repeated elimination of
 * terminal branches of topographic 2D/3D skeletons
 * https://github.com/tferr/Scripts#scripts
 * Tiago Ferreira, v1.2.1 2014.04.05
 *
 * Requirements:
 * Ignacio Arganda-Carreras Skeletonize (http://fiji.sc/Skeletonize3D) and AnalyzeSkeleton
 * (http://fiji.sc/AnalyzeSkeleton) plugins, both bundled with Fiji (http://fiji.sc/)
 *
 * Installation:
 * Update ImageJ to version 1.47m (or newer). Save this file in the plugins/ folder using
 * the 'Plugins>Install...' command.
 *
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software Foundation
 * (http://www.gnu.org/licenses/gpl.txt).
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.
 */

import ij.gui.Overlay;
import ij.text.*;
import skeleton_analysis.*;
import Skeletonize3D_.*;


/* Output definitions */
String[] OUT_CHOICES = {"None", "Iteration Stack (IS)", "Color Map (CM)", "Both IS & CM"};
int OUT_NONE = 0; int OUT_IS = 1; int OUT_CM = 2; int OUT_ISCM = 3;

/* Default settings */
int maxPruning = 10; // Max. number of prunning cycles
int pruneChoice = AnalyzeSkeleton_.SHORTEST_BRANCH; // default option for loop detection
int outChoice = OUT_CM; // Default OUT_CHOICES choice
boolean protectRoot = true; // If an area ROI is present, should we assume it contains the root branch?

/* Reminds the user to install required dependencies */
boolean validInstallation() {
    try {
        Class.forName("skeleton_analysis.AnalyzeSkeleton_");
        Class.forName("Skeletonize3D_.Skeletonize3D_");
        return true;
    } catch( ClassNotFoundException e ) {
        URL = "http://jenkins.imagej.net/job/Stable-Fiji/ws/Fiji.app/plugins/";
        AS_VRSN = "AnalyzeSkeleton_-2.0.0-SNAPSHOT.jar";
        SK_VRSN = "Skeletonize3D_-1.0.1-SNAPSHOT.jar";
        msg = "\n**** Strahler Analysis Error: Required file(s) not found:\n"+ e +"\n \n"
            + "Strahler Analysis requires AnalyzeSkeleton_.jar and Skeletonize3D_.jar to be installed in\n"
            + "the plugins/ folder. Please install the missing file(s) by double-clicking on the links below:\n \n"
            + URL + AS_VRSN +"\n"+ URL + SK_VRSN;
        IJ.log(msg);
        lw = WindowManager.getFrame("Log");
        if (lw!=null) lw.setSize(645, 270);
        return false;
    }
}

/*
 * Creates the dialog prompt, retrieving the image with the original structure. While it
 * is unlikely that the iterative pruning of terminal branches will cause new loops on
 * pre-existing skeletons, offering the option to resolve loops with intensity based
 * methods remains useful when analyzing non-thinned grayscale images.
 */
ImagePlus getOriginalImp(ImagePlus currentImp, String currentTitle) {

    ImagePlus origImg = currentImp;
    gd = new GenericDialog("Strahler Analysis of "+ currentTitle);
    gd.addSlider("Max. number of iterations:", 1, 20, maxPruning);

    // Can we offer intensity based pruning?
    int[] ids = WindowManager.getIDList();
    singleImage = (ids==null || ids.length<2);

    if (singleImage) { // Only skeleton image is open

        String[] S_CHOICES = { AnalyzeSkeleton_.pruneCyclesModes[AnalyzeSkeleton_.NONE],
                    AnalyzeSkeleton_.pruneCyclesModes[AnalyzeSkeleton_.SHORTEST_BRANCH]};
        gd.addChoice("Elimination of skeleton loops:", S_CHOICES, S_CHOICES[pruneChoice]);

    } else { // Non-thinned image may be available

        gd.addChoice("Elimination of skeleton loops:", AnalyzeSkeleton_.pruneCyclesModes,
                    AnalyzeSkeleton_.pruneCyclesModes[pruneChoice]);
        imgTitles = new String[ids.length];
        for (i = 0; i < ids.length; ++i )
            imgTitles[i] = (WindowManager.getImage(ids[i])).getTitle();
        gd.addChoice("Original grayscale image:", imgTitles, currentTitle);

    }

    gd.addChoice("Output image(s):", OUT_CHOICES , OUT_CHOICES[outChoice]);
    gd.addMessage("Branches of highest Strahler order (roots):", new Font("SansSerif", Font.BOLD, 12));
    gd.setInsets(2, 30, 0);
    if (protectRoot)
        gd.addCheckbox("Protect branches inside ROI from iterative prunning", protectRoot);
    else
        gd.addMessage("No area ROI was found. No roots will be considered.\nAll branches will be affected by the iteration.");
    gd.addHelp("http://fiji.sc/Strahler_Analysis");
    gd.showDialog();
    if (gd.wasCanceled())
        return null;
    maxPruning = (int)gd.getNextNumber();
    pruneChoice = gd.getNextChoiceIndex();
    if (!singleImage) {
        imgChoice = gd.getNextChoiceIndex();
        if (pruneChoice==AnalyzeSkeleton_.LOWEST_INTENSITY_VOXEL || pruneChoice==AnalyzeSkeleton_.LOWEST_INTENSITY_BRANCH)
        origImg = WindowManager.getImage(imgChoice);
    }
    outChoice = gd.getNextChoiceIndex();
    protectRoot = gd.getNextBoolean();
    return origImg;
}

/* Outputs measurements to a dedicated table */
void printResults(order, tips, ratios, junctions) {
    strahlerTable = "Strahler_Table";
    window = WindowManager.getFrame(strahlerTable);
    if (window == null)
        rt = new ResultsTable();
    else
        rt = ((TextWindow) window).getTextPanel().getResultsTable();
    rt.setPrecision(0);
    rt.incrementCounter();
    rt.addLabel("Image", title);
    rt.addValue("Strahler order", order);
    rt.addValue("# End-point branches", tips);
    rt.addValue("Ramification ratios", IJ.d2s(ratios,5));
    rt.addValue("# Prevailing junctions", junctions);
    rt.show(strahlerTable);
}

/* Adds "Root ROI" to the image overlay */
void addRootToOverlay(ImagePlus imp, Roi roi, boolean label) {
    Overlay overlay = imp.getOverlay();
    if (overlay==null) overlay = new Overlay();
    roi.setName("Root");
    overlay.add(roi);
    if (label) {
        overlay.setLabelColor(roi.getColor());
        overlay.drawNames(true);
    }
    imp.setOverlay(overlay);
}

// Exit if required plugins are not installed
if (!validInstallation())
    { IJ.error("Missing files? See Log window for details."); return; }

// Get active image
srcImp = WindowManager.getCurrentImage();
if (srcImp==null)
    { IJ.error("There are no images open."); return; }
if (srcImp.getBitDepth()!=8)
    { IJ.error("Only 8-bit grayscale images can be processed."); return; }

// Root protection?
Roi roi = srcImp.getRoi();
protectRoot = roi!=null && roi.isArea();

// Prompt for options & retrieve original image for intensity-based pruning of skel. loops
origImp = getOriginalImp(srcImp, title = srcImp.getTitle() );
if (origImp==null)
    return;

// Produce an image output?
boolean debug = outChoice!=OUT_NONE;

// Work on an copy, since the original image will be modified
if (roi!=null) srcImp.killRoi();
ImagePlus imp = srcImp.duplicate();
ImageProcessor ip = imp.getProcessor();
if (roi!=null) srcImp.setRoi(roi);

// Create image that will reinstate the root ROI
ImagePlus rootImp;
if (protectRoot) {

    rootImp = imp.duplicate();
    rootImp.setRoi(roi);
    for (i=1; i<=rootImp.getNSlices(); i++) {
        rootIp = rootImp.getStack().getProcessor(i);
        rootIp.setValue(0.0);
        rootIp.fillOutside(roi);
    }
    // Skeletonize root
    thinRoot = new Skeletonize3D_();
    thinRoot.setup("", rootImp);
    thinRoot.run(rootImp.getProcessor());

}

// Use Z-projections to populate animation stacks when dealing with 3D skeletons
int nSlices = imp.getNSlices();
if (nSlices>1 && debug) {
    zp = new ZProjector(imp);
    zp.setMethod(ZProjector.MAX_METHOD);
    zp.setStartSlice(1);
    zp.setStopSlice(nSlices);
}

// Initialize Skeletonize3D_ and AnalyzeSkeleton_
thin = new Skeletonize3D_();
thin.setup("", imp);
skel = new AnalyzeSkeleton_();
skel.setup("", imp);

if (debug)
    newStack = new ImageStack( imp.getWidth(), imp.getHeight() );

int order = 1; boolean loop = true; double prevEndPointBranches = Double.NaN;
//int smallestNBranches = Integer.MAX_VALUE;

do {

    // (Re)skeletonize stack in case pruned structure is no longer a skeleton
    thin.run(ip);

    // Add current skeleton to debug animation
    if (debug) {
        if (nSlices>1) {
            zp.doProjection();
            ipd = zp.getProjection().getProcessor();
        } else {
            ipd = ip.duplicate();
        }
        newStack.addSlice("Order "+ IJ.pad(order, 2), ipd);
    }

    IJ.showStatus("Retrieving measurements for order "+ order +"...");
    IJ.showProgress(order, maxPruning);

    // Retrieve measurements (http://fiji.sc/javadoc/skeleton_analysis/):
    // AnalyzeSkeleton_.run(int pruneIndex, boolean pruneEnds, boolean shortPath,
    //                      ImagePlus origIP, boolean silent, boolean verbose)
    skelResult = skel.run(pruneChoice, false, false, origImp, true, false);

    // Read results
    branches = skelResult.getBranches();
    endPoints = skelResult.getEndPoints();
    junctions = skelResult.getJunctions();
    maxLengths = skelResult.getMaximumBranchLength();

    // Calculate sums
    endPointBranches = 0; totalJunctions = 0;
    for (i=0; i<branches.length; i++) {
        if (maxLengths[i]!=0) { // Ignore any branch of length zero
            endPointBranches += endPoints[i]; // Sum all endPointVoxels
            if (branches[i]==1) endPointBranches--; // Isolated branches have 2 end-points
            totalJunctions += junctions[i];
        }
    }

    // Exit if elimination of terminal branches has ended
    if (endPointBranches<1) break;

    // Are there any loops upon elimination of terminal branches?
    if (prevEndPointBranches==endPointBranches)
        IJ.log("\n*** Strahler analysis of "+ title +", iteration "+ order +":\n"
             + "It is likely that the skeleton contains loops at this step. Revise parameters?");

    // Print results
    printResults(order++, endPointBranches, prevEndPointBranches/endPointBranches, totalJunctions);
    //smallestNBranches = Math.min(branches.length, smallestNBranches);
    prevEndPointBranches = endPointBranches;


    // Eliminate terminal branches
    skel.run(AnalyzeSkeleton_.NONE, true, false, null, true, false);

    // Reinstate root ROI
    if (protectRoot) {
        (new ImageCalculator()).run("OR stack", imp, rootImp);
    }

    // Continue?
    loop = order<=maxPruning && totalJunctions>0 ;

} while (loop);

if (debug) {

    cal = srcImp.getCalibration();
    imp2 = new ImagePlus("StrahlerAnimation_"+ title, newStack);
    imp2.setCalibration(cal);

    if (outChoice==OUT_IS || outChoice==OUT_ISCM) { // Display iteration stack
        if (protectRoot) addRootToOverlay(imp2, roi, true);
        imp2.show();
    }
    if (outChoice==OUT_CM || outChoice==OUT_ISCM) { // Create color map
        zp = new ZProjector(imp2);
        zp.setMethod(ZProjector.SUM_METHOD);
        zp.doProjection();
        ip3 = zp.getProjection().getProcessor();
        ip3.multiply(1/255.0);
        ip3.setMinAndMax(0, order-1);
        imp3 = new ImagePlus("StrahlerColors_"+ title, ip3.convertToShortProcessor(false));
        IJ.run(imp3, "Fire", "");
        IJ.run(imp3, "Calibration Bar...", " overlay"); // Calibration bar seems to clear pre-existing overlays
        imp3.setCalibration(cal);
        if (protectRoot) addRootToOverlay(imp3, roi, false);
        imp3.show();
    }
}

IJ.showProgress(0, 0);
IJ.showTime(imp, imp.getStartTime(), "Strahler Analysis concluded... ");
