/* Strahler_Analysis.bsh
 * BeanShell script that performs Strahler analysis in ImageJ by repeated elimination of
 * terminal branches of topographic 2D/3D skeletons
 * https://github.com/tferr/Scripts#scripts
 * Tiago Ferreira, v1.2.3 2014.04.14
 *
 * Requirements:
 * Ignacio Arganda-Carreras Skeletonize (http://fiji.sc/Skeletonize3D) and AnalyzeSkeleton
 * (http://fiji.sc/AnalyzeSkeleton) plugins, both bundled with Fiji (http://fiji.sc/)
 *
 * Installation:
 * Save this file in the plugins/ folder using the 'Plugins>Install...' command.
 *
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software Foundation
 * (http://www.gnu.org/licenses/gpl.txt).
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.
 */

import ij.gui.Overlay;
import ij.text.*;
import skeleton_analysis.*;
import Skeletonize3D_.*;


/* Output definitions */
String[] OUT_CHOICES = {"None", "Iteration Stack (IS)", "Color Map (CM)", "Both IS & CM"};
int OUT_NONE = 0; int OUT_IS = 1; int OUT_CM = 2; int OUT_ISCM = 3;

/* Default settings */
int maxPruning = 10;        // Max. number of prunning cycles
int outChoice = OUT_CM;     // Default OUT_CHOICES choice
boolean protectRoot = true; // If an area ROI is present, should we assume it contains the root branch?
int pruneChoice = AnalyzeSkeleton_.SHORTEST_BRANCH; // Default option for loop detection


/* Reminds the user to install required dependencies */
boolean validInstallation() {
    try {
        Class.forName("skeleton_analysis.AnalyzeSkeleton_");
        Class.forName("Skeletonize3D_.Skeletonize3D_");
        return true;
    } catch( ClassNotFoundException e ) {
        URL = "http://jenkins.imagej.net/job/Stable-Fiji/ws/Fiji.app/plugins/";
        AS_VRSN = "AnalyzeSkeleton_-2.0.0-SNAPSHOT.jar";
        SK_VRSN = "Skeletonize3D_-1.0.1-SNAPSHOT.jar";
        msg = "\n**** Strahler Analysis Error: Required file(s) not found:\n"+ e +"\n \n"
            + "Strahler Analysis requires AnalyzeSkeleton_.jar and Skeletonize3D_.jar to be installed in\n"
            + "the plugins/ folder. Please install the missing file(s) by double-clicking on the links below:\n \n"
            + URL + AS_VRSN +"\n"+ URL + SK_VRSN;
        IJ.log(msg);
        lw = WindowManager.getFrame("Log");
        if (lw!=null) lw.setSize(645, 270);
        return false;
    }
}

/*
 * Creates the dialog prompt, retrieving the image with the original structure. While it
 * is unlikely that the iterative pruning of terminal branches will cause new loops on
 * pre-existing skeletons, offering the option to resolve loops with intensity based
 * methods remains useful when analyzing non-thinned grayscale images.
 */
ImagePlus getOriginalImp(ImagePlus currentImp, String currentTitle) {

    ImagePlus origImg = currentImp;
    gd = new GenericDialog("Strahler Analysis of "+ currentTitle);
    gd.addSlider("Max. number of iterations:", 1, 20, maxPruning);

    // Can we offer intensity based pruning?
    int[] ids = WindowManager.getIDList();
    singleImage = (ids==null || ids.length<2);

    if (singleImage) { // Only skeleton image is open

        String[] S_CHOICES = { AnalyzeSkeleton_.pruneCyclesModes[AnalyzeSkeleton_.NONE],
                    AnalyzeSkeleton_.pruneCyclesModes[AnalyzeSkeleton_.SHORTEST_BRANCH]};
        gd.addChoice("Elimination of skeleton loops:", S_CHOICES, S_CHOICES[pruneChoice]);

    } else { // Non-thinned image may be available

        gd.addChoice("Elimination of skeleton loops:", AnalyzeSkeleton_.pruneCyclesModes,
                    AnalyzeSkeleton_.pruneCyclesModes[pruneChoice]);
        imgTitles = new String[ids.length];
        for (i = 0; i < ids.length; ++i )
            imgTitles[i] = (WindowManager.getImage(ids[i])).getTitle();
        gd.addChoice("Original grayscale image:", imgTitles, currentTitle);

    }

    gd.addChoice("Output image(s):", OUT_CHOICES , OUT_CHOICES[outChoice]);
    gd.addMessage("Non-radial arbors:", new Font("SansSerif", Font.BOLD, 12));
    gd.setInsets(2, 20, 0);
    if (protectRoot) {
        gd.addCheckbox("Protect branch inside ROI from iterative pruning", protectRoot);
        gd.addMessage("ROI should contain a single terminal branch corresponding\n"
                    + "   to the root node and having the highest Strahler order.");
    }
    else
        gd.addMessage("No area ROI was found. All branches will be affected\nby the iterative pruning.");
    gd.addHelp("http://fiji.sc/Strahler_Analysis");
    gd.showDialog();
    if (gd.wasCanceled())
        return null;
    maxPruning = (int)gd.getNextNumber();
    pruneChoice = gd.getNextChoiceIndex();
    if (!singleImage) {
        imgChoice = gd.getNextChoiceIndex();
        if (pruneChoice==AnalyzeSkeleton_.LOWEST_INTENSITY_VOXEL || pruneChoice==AnalyzeSkeleton_.LOWEST_INTENSITY_BRANCH)
        origImg = WindowManager.getImage(imgChoice);
    }
    outChoice = gd.getNextChoiceIndex();
    if (protectRoot) {
        protectRoot = gd.getNextBoolean();
    }
    return origImg;
}

/* Outputs measurements to a dedicated table */
void printResults(order, tips, ratios, junctions) {
    strahlerTable = "Strahler_Table";
    window = WindowManager.getFrame(strahlerTable);
    if (window == null)
        rt = new ResultsTable();
    else
        rt = ((TextWindow) window).getTextPanel().getResultsTable();
    rt.setPrecision(0);
    rt.incrementCounter();
    rt.addLabel("Image", title);
    rt.addValue("Strahler order", order);
    rt.addValue("# End-point branches", tips);
    rt.addValue("Ramification ratios", IJ.d2s(ratios,5));
    rt.addValue("# Prevailing junctions", junctions);
    rt.show(strahlerTable);
}

/* Adds "Root ROI" to the image overlay */
void addRootToOverlay(ImagePlus imp, Roi roi, boolean label) {
    Overlay overlay = imp.getOverlay();
    if (overlay==null) overlay = new Overlay();
    roi.setName("Root");
    overlay.add(roi);
    if (label) {
        overlay.setLabelColor(roi.getColor());
        overlay.drawNames(true);
    }
    imp.setOverlay(overlay);
}

// Exit if required plugins are not installed
if (!validInstallation())
    { IJ.error("Missing files? See Log window for details."); return; }

// Get active image
srcImp = WindowManager.getCurrentImage();
if (srcImp==null)
    { IJ.error("There are no images open."); return; }
if (srcImp.getBitDepth()!=8)
    { IJ.error("Only 8-bit grayscale images can be processed."); return; }

// Root protection?
Roi roi = srcImp.getRoi();
protectRoot = roi!=null && roi.isArea();

// Prompt for options & retrieve original image for intensity-based pruning of skel. loops
origImp = getOriginalImp(srcImp, title = srcImp.getTitle() );
if (origImp==null)
    return;

// Produce an image output?
boolean debug = outChoice!=OUT_NONE;

// Work on a copy, since the original image will be modified
if (roi!=null) srcImp.killRoi();
ImagePlus imp = srcImp.duplicate();
ImageProcessor ip = imp.getProcessor();
if (roi!=null) srcImp.setRoi(roi);

// Skeletonize in case image is not a skeleton
if (roi!=null) imp.killRoi();
thin = new Skeletonize3D_();
thin.setup("", imp);
thin.run(ip);

ImagePlus rootImp;
int rootTotalJunctions = 0;
int rootEndPointBranches = 0;

if (protectRoot) {

    // Create root image: a skeleton containing only branches inside ROI
    rootImp = imp.duplicate();
    rootImp.setRoi(roi);
    for (i=1; i<=rootImp.getNSlices(); i++) {
        rootIp = rootImp.getStack().getProcessor(i);
        rootIp.setValue(0.0);
        rootIp.fillOutside(roi);
    }
    rootImp.killRoi();

    // Analyze root. We'll use its total n. of junctions as an identifier
    root = new AnalyzeSkeleton_();
    root.setup("", rootImp);
    rootResult = root.run(pruneChoice, false, false, origImp, true, false);
    rootBranches = rootResult.getBranches();
    rootEndPoints = rootResult.getEndPoints();
    rootJunctions = rootResult.getJunctions();
    rootMaxLengths = rootResult.getMaximumBranchLength();
    for (i=0; i<rootBranches.length; i++) {
        if (rootMaxLengths[i]!=0) { // Ignore any branch of length zero
            rootEndPointBranches += rootEndPoints[i];
            if (rootBranches[i]==1) rootEndPointBranches--;
            rootTotalJunctions += rootJunctions[i];
        }
    }

}

String warning = "";
if (protectRoot && rootEndPointBranches>1) {
    warning = "ROI contains "+ rootEndPointBranches +" branches. Strahler counts will likely be inaccurate.\n";
    if (!IJ.showMessageWithCancel("Warning", warning +"Continue nevertheless?"))
        return;
}

// Use Z-projections to populate animation stacks when dealing with 3D skeletons
int nSlices = imp.getNSlices();
if (nSlices>1 && debug) {
    zp = new ZProjector(imp);
    zp.setMethod(ZProjector.MAX_METHOD);
    zp.setStartSlice(1);
    zp.setStopSlice(nSlices);
}

// Initialize AnalyzeSkeleton_
skel = new AnalyzeSkeleton_();
skel.setup("", imp);

if (debug)
    newStack = new ImageStack( imp.getWidth(), imp.getHeight() );

int order = 1; boolean loop = true; double prevEndPointBranches = Double.NaN;
String msg = "\n*** Strahler analysis of "+ title +" ***\n"+ warning;

do {

    // Re-skeletonize image. This ensures no disconnected pixels exist after prunning
    thin.run(ip);

    // Add current skeleton to debug animation
    if (debug) {
        if (nSlices>1) {
            zp.doProjection();
            ipd = zp.getProjection().getProcessor();
        } else {
            ipd = ip.duplicate();
        }
        newStack.addSlice("Order "+ IJ.pad(order, 2), ipd);
    }

    IJ.showStatus("Retrieving measurements for order "+ order +"...");
    IJ.showProgress(order, maxPruning);

    // Retrieve measurements (http://fiji.sc/javadoc/skeleton_analysis/):
    // AnalyzeSkeleton_.run(int pruneIndex, boolean pruneEnds, boolean shortPath, ImagePlus origIP, boolean silent, boolean verbose)
    skelResult = skel.run(pruneChoice, false, false, origImp, true, false);

    // Read results
    branches = skelResult.getBranches();
    endPoints = skelResult.getEndPoints();
    junctions = skelResult.getJunctions();
    maxLengths = skelResult.getMaximumBranchLength();

    // Calculate sums
    endPointBranches = -rootEndPointBranches; // initialized to zero if !protectRoot
    totalJunctions = -rootTotalJunctions;     // initialized to zero if !protectRoot
    for (i=0; i<branches.length; i++) {
        if (maxLengths[i]!=0) { // Ignore any branch of length zero
            endPointBranches += endPoints[i]; // Sum all endPointVoxels
            if (branches[i]==1) endPointBranches--; // Isolated branches have 2 end-points
            totalJunctions += junctions[i];
        }
    }

    // Are there any loops in the skeleton?
    if (prevEndPointBranches==endPointBranches) {
        msg += "Iteration "+ order + ": Skeleton may contain loops at this step. Revise parameters?\n";
        break;
    }

    // Have a final look at the last iteration
    if (protectRoot && (order==maxPruning || totalJunctions==0)) {

        if (endPointBranches<0) { // Something strange happened
            msg += "Inaccurate count. Please revise analysis.\n";
            endPointBranches = Math.max(1, rootEndPointBranches-1);
        } else if (endPointBranches==0) { // Root remains connected to arbor
            endPointBranches = Math.max(1, rootEndPointBranches-1);
        } else  { // Root is disconnected
            endPointBranches = endPointBranches + rootEndPointBranches;
        }

    }

    // Print results
    printResults(order++, endPointBranches, prevEndPointBranches/endPointBranches, totalJunctions);
    prevEndPointBranches = endPointBranches;

    // Eliminate terminal branches
    skel.run(AnalyzeSkeleton_.NONE, true, false, null, true, false);

    if (protectRoot) { // Reinstate branches in root ROI
        (new ImageCalculator()).run("OR stack", imp, rootImp);
    }

    // Continue?
    loop = order<=maxPruning && totalJunctions>0;

} while (loop);

if (debug) {

    cal = srcImp.getCalibration();
    imp2 = new ImagePlus("StrahlerAnimation_"+ title, newStack);
    imp2.setCalibration(cal);

    if (outChoice==OUT_IS || outChoice==OUT_ISCM) { // Display iteration stack
        if (protectRoot) addRootToOverlay(imp2, roi, true);
        imp2.show();
    }
    if (outChoice==OUT_CM || outChoice==OUT_ISCM) { // Create color map
        zp = new ZProjector(imp2);
        zp.setMethod(ZProjector.SUM_METHOD);
        zp.doProjection();
        ip3 = zp.getProjection().getProcessor();
        ip3.multiply(1/255.0);
        ip3.setMinAndMax(0, order-1);
        imp3 = new ImagePlus("StrahlerColors_"+ title, ip3.convertToShortProcessor(false));
        IJ.run(imp3, "Fire", "");
        IJ.run(imp3, "Calibration Bar...", " overlay"); // NB: Calibration bar clears pre-existing overlays. Bug?
        imp3.setCalibration(cal);
        if (protectRoot) addRootToOverlay(imp3, roi, false);
        imp3.show();
    }
}

if (!msg.endsWith(" ***\n")) {
    if (protectRoot)
        msg += "Properties of arbor inside ROI: "+ (rootEndPointBranches-1) +" terminal branches; "+ rootTotalJunctions +" junction(s).";
    IJ.log(msg);
}
IJ.showProgress(0, 0);
IJ.showTime(imp, imp.getStartTime(), "Strahler Analysis concluded... ");
