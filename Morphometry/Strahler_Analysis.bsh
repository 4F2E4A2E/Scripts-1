/* Strahler_Analysis.bsh
 * BeanShell script that performs Strahler analysis in ImageJ by repeated elimination of
 * terminal branches of topographic 2D/3D skeletons
 * https://github.com/tferr/Scripts#scripts
 * Tiago Ferreira, v1.1.1 2014.04.04
 *
 * Requirements:
 * Ignacio Arganda-Carreras Skeletonize (http://fiji.sc/Skeletonize3D) and AnalyzeSkeleton
 * (http://fiji.sc/AnalyzeSkeleton) plugins, both bundled with Fiji (http://fiji.sc/)
 *
 * Installation:
 * Update ImageJ to version 1.47m (or newer). Save this file in the plugins/ folder using
 * the 'Plugins>Install...' command.
 *
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software Foundation
 * (http://www.gnu.org/licenses/gpl.txt).
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.
 */

import ij.text.*;
import skeleton_analysis.*;
import Skeletonize3D_.*;


/* Output definitions */
String[] OUT_CHOICES = {"None", "Iteration Stack (IS)", "Color Map (CM)", "Both IS & CM"};
int OUT_NONE = 0; int OUT_IS = 1; int OUT_CM = 2; int OUT_ISCM = 3;

/* Default settings */
int maxPruning = 10; // Max. number of prunning cycles
int pruneChoice = AnalyzeSkeleton_.SHORTEST_BRANCH; // default option for loop detection
int outChoice = OUT_CM; // Default OUT_CHOICES choice

/* Reminds the user to install required dependencies */
boolean validInstallation() {
    try {
        Class.forName("skeleton_analysis.AnalyzeSkeleton_");
        Class.forName("Skeletonize3D_.Skeletonize3D_");
        return true;
    } catch( ClassNotFoundException e ) {
        URL = "http://jenkins.imagej.net/job/Stable-Fiji/ws/Fiji.app/plugins/";
        AS_VRSN = "AnalyzeSkeleton_-2.0.0-SNAPSHOT.jar";
        SK_VRSN = "Skeletonize3D_-1.0.1-SNAPSHOT.jar";
        msg = "\n**** Strahler Analysis Error: Required file(s) not found:\n"+ e +"\n \n"
            + "Strahler Analysis requires AnalyzeSkeleton_.jar and Skeletonize3D_.jar to be installed in\n"
            + "the plugins/ folder. Please install the missing file(s) by double-clicking on the links below:\n \n"
            + URL + AS_VRSN +"\n"+ URL + SK_VRSN;
        IJ.log(msg);
        lw = WindowManager.getFrame("Log");
        if (lw!=null) lw.setSize(645, 270);
        return false;
    }
}

/*
 * Creates the dialog prompt, retrieving the image with the original structure. While it
 * is unlikely that the iterative pruning of terminal branches will cause new loops on
 * pre-existing skeletons, offering the option to resolve loops with intensity based
 * methods remains useful when analyzing non-thinned grayscale images.
 */
ImagePlus getOriginalImp(ImagePlus currentImp, String currentTitle) {
    msg = "<html>This script performs Strahler analysis on topographic skeletons (2D/3D) through<br>"
        + "progressive pruning of terminal branches.<br<br>"
        + "Note that determination of Horton-Strahler numbers by iterative tree simplifcation<br>"
        + "would require detecting all terminal branches and all the degree-one paths leading<br>"
        + "to them. This script detects only the former (not both). Nevertheless, it should<br>"
        + "provide satisfactory results when dealing with radial arbors, as long as the<br>"
        + "skeletonized representation of the original structure is accurate.<br><br>"
        + "<b>Max. number of iterations</b> The maximum number of elimination steps to be used,<br>"
        + "i.e., the highest Strahler order (\"root node\") to be considered. Note that the analysis<br>"
        + "will stop as soon as there are no junction points in the skeleton, which may happen<br>"
        + "before the specified cycle.<br><br>"
        + "<b>Elimination of skeleton loops</b> AnalyzeSkeleton is able to resolve closed loops in<br>"
        + "the skeleton. The available methods are described on the plugin documentation<br>"
        + "page, <u>http://fiji.sc/AnalyzeSkeleton</u>.<br><br>"
        + "<b>Original grayscale image</b> The initial non-thinned image to be used for intensity-<br>"
        + "based elimination of closed loops (this option is only available when at least two<br>"
        + "images are opened).";

    ImagePlus origImg = currentImp;
    gd = new GenericDialog("Strahler Analysis of "+ currentTitle);
    gd.addNumericField("Max. number of iterations:", maxPruning, 0);

    // Can we offer intensity based pruning?
    int[] ids = WindowManager.getIDList();
    singleImage = (ids==null || ids.length<2);

    if (singleImage) { // Only skeleton image is open

        String[] S_CHOICES = { AnalyzeSkeleton_.pruneCyclesModes[AnalyzeSkeleton_.NONE],
                    AnalyzeSkeleton_.pruneCyclesModes[AnalyzeSkeleton_.SHORTEST_BRANCH]};
        gd.addChoice("Elimination of skeleton loops:", S_CHOICES, S_CHOICES[pruneChoice]);

    } else { // Non-thinned image may be available

        gd.addChoice("Elimination of skeleton loops:", AnalyzeSkeleton_.pruneCyclesModes,
                    AnalyzeSkeleton_.pruneCyclesModes[pruneChoice]);
        imgTitles = new String[ids.length];
        for (i = 0; i < ids.length; ++i )
            imgTitles[i] = (WindowManager.getImage(ids[i])).getTitle();
        gd.addChoice("Original grayscale image:", imgTitles, currentTitle);

    }

    gd.addChoice("Output image(s):", OUT_CHOICES , OUT_CHOICES[outChoice]);
    gd.addHelp(msg);
    gd.showDialog();
    if (gd.wasCanceled())
        return null;
    maxPruning = (int)gd.getNextNumber();
    pruneChoice = gd.getNextChoiceIndex();
    if (!singleImage) {
        imgChoice = gd.getNextChoiceIndex();
        if (pruneChoice==AnalyzeSkeleton_.LOWEST_INTENSITY_VOXEL || pruneChoice==AnalyzeSkeleton_.LOWEST_INTENSITY_BRANCH)
        origImg = WindowManager.getImage(imgChoice);
    }
    outChoice = gd.getNextChoiceIndex();
    return origImg;
}

/* Outputs measurements to a dedicated table */
void printResults(order, tips, ratios, junctions) {
    strahlerTable = "Strahler_Table";
    window = WindowManager.getFrame(strahlerTable);
    if (window == null)
        rt = new ResultsTable();
    else
        rt = ((TextWindow) window).getTextPanel().getResultsTable();
    rt.setPrecision(0);
    rt.incrementCounter();
    rt.addLabel("Image", title);
    rt.addValue("Strahler order", order);
    rt.addValue("# End-point branches", tips);
    rt.addValue("Ramification ratios", IJ.d2s(ratios,5));
    rt.addValue("# Prevailing junctions", junctions);
    rt.show(strahlerTable);
}


// Exit if required plugins are not installed
if (!validInstallation())
    { IJ.error("Missing files? See Log window for details."); return; }

// Get active image
srcImp = WindowManager.getCurrentImage();
if (srcImp==null)
    { IJ.error("There are no images open."); return; }
if (srcImp.getBitDepth()!=8)
    { IJ.error("Only 8-bit grayscale images can be processed."); return; }

// Prompt for options & retrieve original image for intensity-based pruning of skel. loops
origImp = getOriginalImp(srcImp, title = srcImp.getTitle() );
if (origImp==null)
    return;

// Produce an image output?
boolean debug = outChoice!=OUT_NONE;

// Work on an copy, since the original image will be modified
imp = srcImp.duplicate();
ip = imp.getProcessor();

// Use Z-projections to populate animation stacks when dealing with 3D skeletons
int nSlices = imp.getNSlices();
if (nSlices>1 && debug) {
    zp = new ZProjector(imp);
    zp.setMethod(ZProjector.MAX_METHOD);
    zp.setStartSlice(1);
    zp.setStopSlice(nSlices);
}

// Initialize Skeletonize3D_ and AnalyzeSkeleton_
thin = new Skeletonize3D_();
thin.setup("", imp);
skel = new AnalyzeSkeleton_();
skel.setup("", imp);

if (debug)
    newStack = new ImageStack( imp.getWidth(), imp.getHeight() );

int order = 1; boolean loop = true; double prevEndPointBranches = Double.NaN;

do {

    // (Re)skeletonize stack in case pruned structure is no longer a skeleton
    thin.run(ip);

    // Add current skeleton to debug animation
    if (debug) {
        if (nSlices>1) {
            zp.doProjection();
            ipd = zp.getProjection().getProcessor();
        } else {
            ipd = ip.duplicate();
        }
        newStack.addSlice("Order "+ IJ.pad(order, 2), ipd);
    }

    IJ.showStatus("Retrieving measurements for order "+ order +"...");
    IJ.showProgress(order, maxPruning);

    // Retrieve measurements (http://fiji.sc/javadoc/skeleton_analysis/):
    // AnalyzeSkeleton_.run(int pruneIndex, boolean pruneEnds, boolean shortPath,
    //                      ImagePlus origIP, boolean silent, boolean verbose)
    skelResult = skel.run(pruneChoice, false, false, origImp, true, false);

    // Read results
    nBranches = skelResult.getBranches();
    endPoints = skelResult.getEndPoints();
    nJunctions = skelResult.getJunctions();
    maxLengths = skelResult.getMaximumBranchLength();

    // Calculate sums
    endPointBranches = 0; totalJunctions = 0;
    for (i=0; i<nBranches.length; i++) {
        if (maxLengths[i]!=0) { // Ignore any branch of length zero
            endPointBranches += endPoints[i]; // Sum all endPointVoxels
            if (nBranches[i]==1) endPointBranches--; // Isolated branches have 2 end-points
            totalJunctions += nJunctions[i];
        }
    }

    // Exit if elimination of terminal branches has ended
    if (endPointBranches==0) break;

    // Are there any loops upon elimination of terminal branches?
    if (prevEndPointBranches==endPointBranches)
        IJ.log("\n**** Strahler Analysis for "+ title +", iteration "+ order +":\n"
             + "It is likely that the skeleton contains loops at this step. Revise parameters?");

    // Print results
    printResults(order++, endPointBranches, prevEndPointBranches/endPointBranches, totalJunctions);
    prevEndPointBranches = endPointBranches;

    // Eliminate terminal branches
    skel.run(AnalyzeSkeleton_.NONE, true, false, null, true, false);

    // Continue?
    loop = order<=maxPruning && totalJunctions>0 ;

} while (loop);

if (debug) {

    cal = imp.getCalibration();
    imp2 = new ImagePlus("StrahlerAnimation_"+ title, newStack);
    imp2.setCalibration(cal);

    if (outChoice==OUT_IS || outChoice==OUT_ISCM) { // Display iteration stack
        imp2.show();
    }
    if (outChoice==OUT_CM || outChoice==OUT_ISCM) { // Create color map
        zp = new ZProjector(imp2);
        zp.setMethod(ZProjector.SUM_METHOD);
        zp.doProjection();
        ip3 = zp.getProjection().getProcessor();
        ip3.multiply(1/255.0);
        ip3.setMinAndMax(0, order-1);
        imp3 = new ImagePlus("StrahlerColors_"+ title, ip3.convertToShortProcessor(false));
        IJ.run(imp3, "Fire", "");
        IJ.run(imp3, "Calibration Bar...", " overlay");
        imp3.setCalibration(cal);
        imp3.show();
    }
}

IJ.showProgress(0, 0);
IJ.showTime(imp, imp.getStartTime(), "Strahler Analysis concluded... ");
imp.updateAndDraw();
